#!/usr/bin/env python3
import sys, os, subprocess, re, glob, socket, webbrowser, shutil, signal, time
from pathlib import Path
from prompt_toolkit import Application
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.layout import Layout, VSplit, HSplit, FloatContainer, Float, Window
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.widgets import TextArea, Button, Dialog
from prompt_toolkit.lexers import PygmentsLexer, Lexer
from prompt_toolkit.document import Document
from prompt_toolkit.application import get_app
from prompt_toolkit.styles import Style
from prompt_toolkit.selection import SelectionType 

try:
    from pygments.lexers import (
        CLexer, CppLexer, PythonLexer, BashLexer, JsonLexer, SqlLexer,
        NasmLexer, CSharpLexer, HtmlLexer, JavascriptLexer, PhpLexer, CssLexer
    )
except Exception:
    from pygments.lexers import CLexer, PythonLexer, BashLexer, JsonLexer, SqlLexer
    from pygments.lexers import HtmlLexer as PhpLexer 
    CppLexer = CLexer; NasmLexer = CLexer; CSharpLexer = CLexer; HtmlLexer = CLexer; JavascriptLexer = CLexer; CssLexer = CLexer

style = Style.from_dict({"search": "bg:#4444ff #ffffff"})
search_state = {"query": "", "matches": [], "current_index": 0, "floating": None}
CURRENT_FILE = None
SPLIT_VIEW = False
CURRENT_MODE = "c"
SERVER_STARTED = False 
RUNNING_PROCS = {} 

editor = TextArea(text="", multiline=True, line_numbers=True, wrap_lines=False, lexer=PygmentsLexer(CLexer), scrollbar=True, focus_on_click=True)
output = TextArea(text="(Results)", multiline=True, read_only=True, wrap_lines=True, scrollbar=True)
editor_window = Window(content=editor.control, wrap_lines=False)
output_window = Window(content=output.control, wrap_lines=True)
left_gutter = Window(width=2, char=" ")
middle_gap = Window(width=2, char=" ")

title_bar = Window(
    height=1, 
    content=FormattedTextControl([('reverse', ' Abyss | Ctrl+O: Save | Ctrl+K: Clear | Ctrl+T: Kill Line | Ctrl+B: Run ')]), 
    style='reverse'
)

body_container = VSplit([left_gutter, editor_window])
root_container = FloatContainer(content=HSplit([title_bar, body_container]), floats=[])
layout_main = Layout(root_container, focused_element=editor_window)

class SearchHighlightLexer(Lexer):
    def __init__(self, base_lexer=None, highlight_word=""):
        self.base_lexer = base_lexer
        self.highlight_word = highlight_word
    def lex_document(self, document):
        def get_line(lineno):
            line = document.lines[lineno]
            result = []
            i = 0
            while i < len(line):
                if self.highlight_word and line[i:i+len(self.highlight_word)] == self.highlight_word:
                    result.append(("class:search", self.highlight_word))
                    i += len(self.highlight_word)
                else: result.append(("", line[i])); i += 1
            return result
        return get_line

def reset_lexer():
    if CURRENT_FILE: detect_mode(CURRENT_FILE)
    else: editor.lexer = PygmentsLexer(CLexer)

def update_search_highlight():
    query = search_state.get("query", "")
    if query: editor.lexer = SearchHighlightLexer(base_lexer=editor.lexer, highlight_word=query)
    else: detect_mode(CURRENT_FILE or "file.c")

def show_output():
    global SPLIT_VIEW
    if not SPLIT_VIEW:
        SPLIT_VIEW = True
        body_container.children = [left_gutter, editor_window, middle_gap, output_window]

def save_file(filename: str):
    global CURRENT_FILE
    CURRENT_FILE = filename
    try:
        with open(filename, "w", encoding="utf-8") as f: f.write(editor.text)
        output.text = f"Saved to {filename}"
        detect_mode(filename)
    except Exception as e: output.text = f"Error: {e}"

def detect_mode(filename: str):
    global CURRENT_MODE
    ext = os.path.splitext(filename)[1].lower()
    map_ext = {
        ".c": (CLexer, "c"), ".h": (CLexer, "c"),
        ".cpp": (CppLexer, "cpp"), ".cc": (CppLexer, "cpp"), ".hpp": (CppLexer, "cpp"),
        ".cs": (CSharpLexer, "csharp"),
        ".py": (PythonLexer, "py"),
        ".sh": (BashLexer, "sh"),
        ".php": (PhpLexer, "php"),
        ".html": (HtmlLexer, "html"), ".htm": (HtmlLexer, "html"),
        ".css": (CssLexer, "css"),
        ".js": (JavascriptLexer, "js"),
        ".json": (JsonLexer, "json"),
        ".sql": (SqlLexer, "sql"),
        ".asm": (NasmLexer, "asm"), ".s": (NasmLexer, "asm")
    }
    info = map_ext.get(ext, (CLexer, "c"))
    editor.lexer = PygmentsLexer(info[0])
    CURRENT_MODE = info[1]

def stop_process(key: str):
    proc = RUNNING_PROCS.get(key)
    if proc:
        try: proc.kill(); proc.wait(timeout=0)
        except: pass
        finally: RUNNING_PROCS.pop(key, None)

kb = KeyBindings()

@kb.add("c-o")
def _(event):
    fname_input = TextArea(multiline=False, height=1, text=CURRENT_FILE or "")
    def on_ok():
        save_file(fname_input.text.strip())
        root_container.floats.pop()
        layout_main.focus(editor_window)
    kb_d = KeyBindings()
    @kb_d.add("enter")
    def _(e): on_ok()
    @kb_d.add("escape")
    def _(e): root_container.floats.pop(); layout_main.focus(editor_window)
    fname_input.control.key_bindings = kb_d
    dialog = Dialog(title="Save As", body=fname_input, buttons=[Button(text="OK", handler=on_ok)], width=60)
    root_container.floats.append(Float(content=dialog))
    layout_main.focus(fname_input.control)

@kb.add("c-z")
def _(event): event.app.current_buffer.undo()

@kb.add("c-y")
def _(event): event.app.current_buffer.redo()

@kb.add("c-c")
def _(event):
    data = event.app.current_buffer.copy_selection()
    event.app.clipboard.set_data(data)
    event.app.current_buffer.exit_selection()

@kb.add("c-x")
def _(event):
    data = event.app.current_buffer.cut_selection()
    event.app.clipboard.set_data(data)

@kb.add("c-v")
def _(event): event.app.current_buffer.paste_clipboard_data(event.app.clipboard.get_data())

@kb.add("c-q")
def _(event): event.app.exit()

@kb.add("c-k")
def _(event):
    buf = event.app.current_buffer
    buf.delete_before_cursor(len(buf.document.current_line_before_cursor))
    buf.delete(len(buf.document.current_line_after_cursor))

@kb.add("c-t")
def _(event):
    buf = event.app.current_buffer
    buf.cursor_position += len(buf.document.current_line_after_cursor)
    buf.delete_before_cursor(len(buf.document.current_line))
    if buf.document.text_after_cursor:
        buf.delete(1)

@kb.add("c-f")
def _(event):
    search_input = TextArea(multiline=False, height=1, text=search_state["query"])
    def do_search():
        query = search_input.text
        search_state["query"] = query
        matches = [m.start() for m in re.finditer(re.escape(query), editor.text)]
        if matches:
            search_state["matches"] = matches
            editor.buffer.cursor_position = matches[0]
            update_search_highlight()
    kb_s = KeyBindings()
    @kb_s.add("enter")
    def _(e): do_search()
    @kb_s.add("escape")
    def _(e): root_container.floats.pop(); reset_lexer(); layout_main.focus(editor_window)
    search_input.control.key_bindings = kb_s
    dialog = Dialog(title="Search", body=search_input, buttons=[Button(text="OK", handler=on_ok)], width=60)
    root_container.floats.append(Float(content=dialog))
    layout_main.focus(search_input.control)

@kb.add("c-b")
def _(event):
    global SERVER_STARTED
    show_output()
    if CURRENT_FILE: save_file(CURRENT_FILE)
    else: return
    ext = os.path.splitext(CURRENT_FILE)[1].lower()
    file_dir = os.path.dirname(os.path.abspath(CURRENT_FILE))
    if ext == ".php":
        if not SERVER_STARTED:
            proc = subprocess.Popen(["php", "-S", "localhost:8080"], cwd=file_dir, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            RUNNING_PROCS["server"] = proc
            SERVER_STARTED = True
        webbrowser.open("http://localhost:8080/" + os.path.basename(CURRENT_FILE))
        return
    temp_exec = "./temp_bin"
    cmd = ""
    if ext == ".c": cmd = f"gcc {CURRENT_FILE} -o {temp_exec} && {temp_exec}"
    elif ext == ".cpp": cmd = f"g++ {CURRENT_FILE} -o {temp_exec} && {temp_exec}"
    elif ext == ".py": cmd = f"python3 {CURRENT_FILE}"
    elif ext == ".sh": cmd = f"bash {CURRENT_FILE}"
    elif ext == ".js": cmd = f"node {CURRENT_FILE}"
    if cmd:
        res = subprocess.getoutput(f"{cmd} 2>&1")
        output.text = res if res.strip() else "(Execution finished)"

@kb.add("enter")
def _(event):
    buf = event.app.current_buffer
    doc = buf.document
    
    current_line = doc.current_line
    
    m = re.match(r'^(\s*)', current_line)
    base_indent = m.group(1) if m else ""
    
    line_after_cursor = doc.current_line_after_cursor
    stripped_line = current_line.rstrip()
    
    if doc.text_before_cursor.endswith("{") and doc.text_after_cursor.startswith("}"):
        buf.delete(1)
        new_indent = base_indent + "    "
        buf.insert_text("\n" + new_indent + "\n" + base_indent + "}")
        buf.cursor_position -= len(base_indent) + 2
    elif stripped_line.endswith("{") and line_after_cursor.strip() == "":
        buf.insert_text("\n" + base_indent + "    ")
    elif CURRENT_MODE in ("py", "asm", "python", "assembly") and stripped_line.endswith(":") and line_after_cursor.strip() == "":
        buf.insert_text("\n" + base_indent + "    ")
    elif stripped_line == "}" and len(base_indent) >= 4:
        buf.insert_text("\n" + base_indent[:-4])
    else:
        buf.insert_text("\n" + base_indent)

@kb.add("tab")
def _(event): event.app.current_buffer.insert_text("    ")

pairs = {"{": "}", "(": ")", "[": "]", "\"": "\"", "'": "'"}
for op, cl in pairs.items():
    @kb.add(op)
    def _(event, op=op, cl=cl):
        event.app.current_buffer.insert_text(op + cl)
        event.app.current_buffer.cursor_left()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        CURRENT_FILE = sys.argv[1]
        if os.path.exists(CURRENT_FILE):
            with open(CURRENT_FILE, "r") as f: editor.text = f.read()
            detect_mode(CURRENT_FILE)
    Application(layout=layout_main, key_bindings=kb, full_screen=True, style=style).run()
    for k in list(RUNNING_PROCS.keys()): stop_process(k)
    if os.path.exists("./temp_bin"):
        try: os.remove("./temp_bin")
        except: pass
